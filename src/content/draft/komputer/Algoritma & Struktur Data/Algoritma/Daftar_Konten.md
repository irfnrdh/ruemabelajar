
    What are Data Structures and Algorithms?
        What is a Data Structure?
            Examples of Data Structures
        What is an Algorithm?
            Types of Algorithms
    In Which Language Should I Write Algorithms?
    How to Learn Algorithms
    Resources for Learning Algorithms
    Conclusion


DSA Introduction

    What is an algorithm?
    Data Structure and Types
    Why learn algorithms?
    Asymptotic Notations
    Master Theorem
    Divide and Conquer Algorithm


Data Structures (I)

    Stack
    Queue
    Types of Queue
    Circular Queue
    Priority Queue
    Deque


Data Structures (II)

    Linked List
    Linked List Operations
    Types of Linked List
    Hash Table
    Heap Data Structure
    Fibonacci Heap
    Decrease Key and Delete node from Fibonacci Heap


Tree based DSA (I)

    Tree Data Structure
    Tree Traversal
    Binary Tree
    Full Binary Tree
    Perfect Binary Tree
    Complete Binary Tree
    Balanced Binary Tree
    Binary Search Tree
    AVL Tree



Tree based DSA (II)

    B Tree
    Insertion into B-tree
    Deletion from B-tree
    B+ Tree
    Insertion on a B+ Tree
    Deletion from a B+ Tree
    Red Black Tree
    Insertion in Red Black Tree
    Deletion from Red Black Tree


Graph based DSA

    Graph Data Structure
    Spanning Tree
    Strongly Connected Components
    Adjacency Matrix
    Adjacency List
    DFS Algorithm
    Breadth-first Search
    Bellman Ford's Algorithm


Sorting and Searching Algorithms

    Bubble Sort
    Selection Sort
    Insertion Sort
    Merge Sort
    Quick Sort
    Counting Sort
    Radix Sort
    Bucket Sort
    Heap Sort
    Shell Sort
    Linear Search
    Binary Search


Greedy Algorithms

    Greedy Algorithm
    Ford-Fulkerson Algorithm
    Dijkstra's Algorithm
    Kruskal's Algorithm
    Prim's Algorithm
    Huffman Code



Dynamic Programming

    Dynamic Programming
    Floyd Warshall Algorithm
    Longest Common Subsequence



Other Algorithms

    Backtracking Algorithm
    Rabin-Karp Algorithm


Introduction to Algorithms

( Playing a Counting Game )
0:25 - What Is an Algorithm?

6:50 - Guess the Number

12:46 - Defining an Algorithm

21:15 - Evaluating Linear Search

29:58 - Evaluating Binary Search


Introduction to Algorithms
( Time Complexity )

36:11 - Efficiency of an Algorithm

42:39 - Constant and Logarithmic Time

49:11 - Linear & Quadratic Time

53:48 - Quasilinear Time

56:23 - Exponential Time

1:04:23 - Determining Complexity

Introduction to Algorithms

( Algorithms in Code )

1:08:22 - Linear Search in Code

1:18:02 - Binary Search in Code

1:28:06 - Recursive Binary Search


Introduction to Algorithms

( Recursion and Space Complexity )

1:41:14 - Recursive Functions

1:46:18 - Space Complexity

1:53:07 - Recap of Algorithms in Code

Introduction to Data Structures

( Exploring Arrays )

1:57:44 - Introduction

2:00:40 - Array Basics

2:06:20 - Accessing a Value in an Array

2:13:06 - Array Search, Insert and Delete


Introduction to Data Structures

( Building a Linked List )

2:22:57 - What Is a Linked List?

2:36:15 - Adding Nodes to a Linked List

2:44:05 - Implementing Search

2:48:34 - Inserting a Node

2:55:20 - Removing a Node


Introduction to Data Structures

( The Merge Sort Algorithm )

3:03:06 - Merge Sort

3:11:13 - Splitting Into Sublists

3:14:27 - Recursively Merging Sublists

3:21:34 - Ensuring the Correctness of Merge Sort

3:28:17 - Evaluating the Runtime of Merge Sort


Introduction to Data Structures

( Sorting a Linked List )

3:35:40 - The Merge Function

3:40:31 - The Divide Step

3:47:56 - The Conquer Step

4:00:11 - Evaluating the Runtime

4:08:46 - Recap of Introduction to Data Structures

Algorithms: Sorting and Searching

( Sorting Algorithms )

4:11:02 - Sorting and Searching

4:14:56 - Bogosort

4:20:36 - Selection Sort

4:27:11 - Getting the Run Time of a Program

4:31:17 - Recursion

4:41:18 - Quicksort

4:47:12 - Implementing Quicksort

4:52:34 - Merge Sort

4:59:45 - Actual Run Time for Sorting Algorithms

5:02:00 - Big-O Run Times of Sorting Algorithms

Algorithms: Sorting and Searching

( Searching Names )

5:07:42 - Linear Search

5:12:04 - Sorting Names

5:14:04 - Binary Search

5:19:22 - Timing Our Search Scripts

5:20:41 - Big O Runtime of Search Algorithms



    What is Algorithm | Introduction to Algorithms
    Definition, Types, Complexity, Examples of Algorithms
    Algorithms Design Techniques
    Why is analysis of an Algorithm important?



    Types of Algorithms:

There are several types of algorithms available. Some important algorithms are:

1. Brute Force Algorithm: It is the simplest approach for a problem. A brute force algorithm is the first approach that comes to finding when we see a problem.

2. Recursive Algorithm: A recursive algorithm is based on recursion. In this case, a problem is broken into several sub-parts and called the same function again and again.

3. Backtracking Algorithm: The backtracking algorithm basically builds the solution by searching among all possible solutions. Using this algorithm, we keep on building the solution following criteria. Whenever a solution fails we trace back to the failure point and build on the next solution and continue this process till we find the solution or all possible solutions are looked after.

4. Searching Algorithm: Searching algorithms are the ones that are used for searching elements or groups of elements from a particular data structure. They can be of different types based on their approach or the data structure in which the element should be found.

5. Sorting Algorithm: Sorting is arranging a group of data in a particular manner according to the requirement. The algorithms which help in performing this function are called sorting algorithms. Generally sorting algorithms are used to sort groups of data in an increasing or decreasing manner.

6. Hashing Algorithm: Hashing algorithms work similarly to the searching algorithm. But they contain an index with a key ID. In hashing, a key is assigned to specific data.

7. Divide and Conquer Algorithm: This algorithm breaks a problem into sub-problems, solves a single sub-problem and merges the solutions together to get the final solution. It consists of the following three steps:

    Divide
    Solve
    Combine

8. Greedy Algorithm: In this type of algorithm the solution is built part by part. The solution of the next part is built based on the immediate benefit of the next part. The one solution giving the most benefit will be chosen as the solution for the next part.

9. Dynamic Programming Algorithm: This algorithm uses the concept of using the already found solution to avoid repetitive calculation of the same part of the problem. It divides the problem into smaller overlapping subproblems and solves them.

10. Randomized Algorithm: In the randomized algorithm we use a random number so it gives immediate benefit. The random number helps in deciding the expected outcome.
Topics:

    Analysis of Algorithms
    Searching and Sorting
    Greedy Algorithms
    Dynamic Programming
    Pattern Searching
    Backtracking
    Divide and Conquer

    Geometric Algorithms
    Mathematical Algorithms
    Bit Algorithms
    Graph Algorithms
    Randomized Algorithms
    Branch and Bound
    Quizzes

Analysis of Algorithms:

    Asymptotic Analysis
    Worst, Average and Best Cases
    Asymptotic Notations
    Lower and Upper Bound Theory
    Introduction to Amortized Analysis
    What does ‘Space Complexity’ mean?
    Polynomial Time Approximation Scheme
    Accounting Method | Amortized Analysis
    Potential Method in Amortized Analysis

Searching and Sorting:

    Introduction to Searching Algorithms
    Introduction to Sorting Algorithm
    Stable and Unstable Sorting Algorithms
    Lower bound for comparison based sorting algorithms
    Can Run Time Complexity of a comparison-based sorting algorithm be less than N logN?
    Which sorting algorithm makes minimum number of memory writes?

Greedy Algorithms:

    Introduction to Greedy Algorithms
    Activity Selection Problem
    Huffman Coding
    Job Sequencing Problem
    Quiz on Greedy Algorithms
    Minimum Number of Platforms Required for a Railway/Bus Station

Dynamic Programming:

    Introduction to Dynamic Programming
    Overlapping Subproblems Property
    Optimal Substructure Property
    Longest Increasing Subsequence
    Longest Common Subsequence
    Min Cost Path
    Coin Change
    Matrix Chain Multiplication
    0-1 Knapsack Problem
    Longest Palindromic Subsequence
    Palindrome Partitioning

Pattern Searching:

    Introduction to Pattern Searching
    Naive Pattern Searching
    KMP Algorithm
    Rabin-Karp Algorithm
    Pattern Searching using a Trie of all Suffixes
    Aho-Corasick Algorithm for Pattern Searching
    Z algorithm (Linear time pattern searching Algorithm)

Backtracking:

    Introduction to Backtracking
    Print all permutations of a given string
    The Knight’s tour problem
    Rat in a Maze
    N Queen Problem
    Subset Sum
    m Coloring Problem
    Hamiltonian Cycle
    Sudoku

Divide and Conquer:

    Introduction to Divide and Conquer
    Merge Sort
    Write your own pow(x, n) to calculate x*n
    Count Inversions
    Closest Pair of Points
    Strassen’s Matrix Multiplication

Geometric Algorithm:

    Introduction to Geometric Algorithms
    Closest Pair of Points | O(nlogn) Implementation
    How to check if a given point lies inside or outside a polygon?
    How to check if two given line segments intersect?
    Given n line segments, find if any two segments intersect
    How to check if given four points form a square
    Convex Hull using Jarvis’ Algorithm or Wrapping

Mathematical Algorithms:

    Introduction to Mathematical Algorithms
    Write an Efficient Method to Check if a Number is Multiple of 3
    Write a program to add two numbers in base 14
    Program for Fibonacci numbers
    Average of a stream of numbers
    Multiply two integers without using multiplication, division and bitwise operators, and no loops
    Babylonian method for square root
    Sieve of Eratosthenes
    Pascal’s Triangle
    Given a number, find the next smallest palindrome
    Program to add two polynomials
    Multiply two polynomials
    Count trailing zeroes in factorial of a number

Bitwise Algorithms:

    Introduction to Bitwise Algorithms
    Little and Big Endian
    Detect opposite signs
    Swap bits
    Turn off the rightmost set bit
    Rotate bits
    Next higher number with same number of set bits
    Swap two nibbles in a byte

Graph Algorithms:

    Introduction to Graph Algorithms
    BFS, DFS
    Cycles in Graph
    Shortest paths
    MST
    Topological Sorting
    Connectivity
    Max Flow

Randomized Algorithms:

    Introduction to Randomized Algorithms
    Linearity of Expectation
    Expected Number of Trials until Success
    Randomized Algorithms | Set 0 (Mathematical Background)
    Randomized Algorithms | Set 1 (Introduction and Analysis)
    Randomized Algorithms | Set 2 (Classification and Applications)
    Randomized Algorithms | Set 3 (1/2 Approximate Median)
    Reservoir Sampling

Branch and Bound:

    Branch and Bound | Set 1 (Introduction with 0/1 Knapsack)
    Branch and Bound | Set 2 (Implementation of 0/1 Knapsack)
    Branch and Bound | Set 3 (8 puzzle Problem)
    Branch And Bound | Set 4 (Job Assignment Problem)
    Branch and Bound | Set 5 (N Queen Problem)
    Branch And Bound | Set 6 (Traveling Salesman Problem)

Quizzes:

    Analysis of Algorithms
    Sorting
    Divide and Conquer
    Greedy Algorithms
    Dynamic Programming
    Backtracking
    NP Complete
    Searching
    Recursion
    Bit Algorithms

Please see Data Structures and Advanced Data Structures for Graph, Binary Tree, BST and Linked List based algorithms.




Data-Structures-and-Algorithms/
│
├── 01_Introduction/
│   ├── 01_Introduction.md
│   └── 02_Importance.md
│
├── 02_Algorithm_Analysis/
│   ├── 01_Big_O_Notation.md
│   ├── 02_Best_Average_Worst_Case.md
│   └── 03_Using_Big_O.md
│
├── 03_Basic_Data_Structures/
│   ├── 01_Array_and_Dynamic_Array.md
│   ├── 02_Linked_Lists.md
│   ├── 03_Stacks_and_Queues.md
│   └── 04_Operations_on_Data_Structures.md
│
├── 04_Searching_and_Sorting/
│   ├── 01_Linear_Binary_Search.md
│   ├── 02_Bubble_Insertion_Selection_Sort.md
│   ├── 03_Quick_Merge_Heap_Sort.md
│   └── 04_Choosing_Algorithms.md
│
├── 05_Trees_and_Graphs/
│   ├── 01_Binary_Trees.md
│   ├── 02_Red_Black_Trees.md
│   ├── 03_Graphs.md
│   └── 04_Operations_on_Trees_and_Graphs.md
│
├── 06_Advanced_Data_Structures/
│   ├── 01_Heap_Priority_Queue.md
│   ├── 02_Hashing_Hash_Table.md
│   ├── 03_Set_Map.md
│   └── 04_Advanced_Graphs.md
│
├── 07_Searching_Shortest_Path/
│   ├── 01_BFS.md
│   ├── 02_DFS.md
│   ├── 03_Dijkstra.md
│   └── 04_Astar.md
│
├── 08_Greedy_Algorithms/
│   ├── 01_Greedy_Algorithms.md
│   ├── 02_Examples.md
│   └── 03_Pros_Cons.md
│
├── 09_Dynamic_Programming/
│   ├── 01_DP_Concepts.md
│   ├── 02_Memoization_Tabulation.md
│   ├── 03_DP_Examples.md
│   └── 04_Comparison_with_Brute_Force.md
│
├── 10_Special_Data_Structures/
│   ├── 01_Trie.md
│   ├── 02_Disjoint_Set_Union.md
│   └── 03_Segment_Tree.md
│
├── 11_Backtracking_Algorithms/
│   ├── 01_Backtracking_Concepts.md
│   ├── 02_Backtracking_Examples.md
│   └── 03_Pruning.md
│
├── 12_Algorithms_in_AI/
│   ├── 01_Genetic_Algorithms.md
│   ├── 02_Particle_Swarm_Optimization.md
│   └── 03_Introduction_to_ML.md
│
├── 13_Real_World_Applications/
│   ├── 01_Using_DS_and_Algorithms_in_Software_Development.md
│   └── 02_Case_Study.md
│
├── 14_Challenges_Considerations/
│   ├── 01_Performance_Memory_Issues.md
│   └── 02_Choosing_Right_Algorithm.md
│
├── 15_Current_Trends/
│   ├── 01_Latest_Trends.md
│   └── 02_DS_Algorithms_in_Parallel_Distributed_Environments.md
│
└── 16_Conclusion/
    ├── 01_Summary.md
    └── 02_Importance_in_Software_Development.md
